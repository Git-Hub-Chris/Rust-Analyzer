// This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-syntax` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borowed mode, and only
//! this mode has all AST accessors.

#![cfg_attr(rustfmt, rustfmt_skip)]

use std::hash::{Hash, Hasher};

use crate::{
    ast,
    SyntaxNode, SyntaxNodeRef, AstNode,
    yellow::{TreeRoot, RaTypes, OwnedRoot, RefRoot},
    SyntaxKind::*,
};

// ArgList
#[derive(Debug, Clone, Copy,)]
pub struct ArgListNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ArgList<'a> = ArgListNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ArgListNode<R1>> for ArgListNode<R2> {
    fn eq(&self, other: &ArgListNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ArgListNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ArgListNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ArgList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ARG_LIST => Some(ArgList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ArgListNode<R> {
    pub fn borrowed(&self) -> ArgList {
        ArgListNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ArgListNode {
        ArgListNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ArgList<'a> {
    pub fn args(self) -> impl Iterator<Item = Expr<'a>> + 'a {
        super::children(self)
    }
}

// ArrayExpr
#[derive(Debug, Clone, Copy,)]
pub struct ArrayExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ArrayExpr<'a> = ArrayExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ArrayExprNode<R1>> for ArrayExprNode<R2> {
    fn eq(&self, other: &ArrayExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ArrayExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ArrayExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ArrayExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ARRAY_EXPR => Some(ArrayExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ArrayExprNode<R> {
    pub fn borrowed(&self) -> ArrayExpr {
        ArrayExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ArrayExprNode {
        ArrayExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ArrayExpr<'a> {}

// ArrayType
#[derive(Debug, Clone, Copy,)]
pub struct ArrayTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ArrayType<'a> = ArrayTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ArrayTypeNode<R1>> for ArrayTypeNode<R2> {
    fn eq(&self, other: &ArrayTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ArrayTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ArrayTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ArrayType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ARRAY_TYPE => Some(ArrayType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ArrayTypeNode<R> {
    pub fn borrowed(&self) -> ArrayType {
        ArrayTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ArrayTypeNode {
        ArrayTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ArrayType<'a> {}

// Attr
#[derive(Debug, Clone, Copy,)]
pub struct AttrNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Attr<'a> = AttrNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<AttrNode<R1>> for AttrNode<R2> {
    fn eq(&self, other: &AttrNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for AttrNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for AttrNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Attr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ATTR => Some(Attr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> AttrNode<R> {
    pub fn borrowed(&self) -> Attr {
        AttrNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> AttrNode {
        AttrNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Attr<'a> {
    pub fn value(self) -> Option<TokenTree<'a>> {
        super::child_opt(self)
    }
}

// BinExpr
#[derive(Debug, Clone, Copy,)]
pub struct BinExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type BinExpr<'a> = BinExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<BinExprNode<R1>> for BinExprNode<R2> {
    fn eq(&self, other: &BinExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for BinExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for BinExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for BinExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            BIN_EXPR => Some(BinExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> BinExprNode<R> {
    pub fn borrowed(&self) -> BinExpr {
        BinExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> BinExprNode {
        BinExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> BinExpr<'a> {}

// BindPat
#[derive(Debug, Clone, Copy,)]
pub struct BindPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type BindPat<'a> = BindPatNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<BindPatNode<R1>> for BindPatNode<R2> {
    fn eq(&self, other: &BindPatNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for BindPatNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for BindPatNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for BindPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            BIND_PAT => Some(BindPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> BindPatNode<R> {
    pub fn borrowed(&self) -> BindPat {
        BindPatNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> BindPatNode {
        BindPatNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for BindPat<'a> {}
impl<'a> BindPat<'a> {}

// Block
#[derive(Debug, Clone, Copy,)]
pub struct BlockNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Block<'a> = BlockNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<BlockNode<R1>> for BlockNode<R2> {
    fn eq(&self, other: &BlockNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for BlockNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for BlockNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Block<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            BLOCK => Some(Block { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> BlockNode<R> {
    pub fn borrowed(&self) -> Block {
        BlockNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> BlockNode {
        BlockNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Block<'a> {
    pub fn statements(self) -> impl Iterator<Item = Stmt<'a>> + 'a {
        super::children(self)
    }

    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// BlockExpr
#[derive(Debug, Clone, Copy,)]
pub struct BlockExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type BlockExpr<'a> = BlockExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<BlockExprNode<R1>> for BlockExprNode<R2> {
    fn eq(&self, other: &BlockExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for BlockExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for BlockExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for BlockExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            BLOCK_EXPR => Some(BlockExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> BlockExprNode<R> {
    pub fn borrowed(&self) -> BlockExpr {
        BlockExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> BlockExprNode {
        BlockExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> BlockExpr<'a> {
    pub fn block(self) -> Option<Block<'a>> {
        super::child_opt(self)
    }
}

// BreakExpr
#[derive(Debug, Clone, Copy,)]
pub struct BreakExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type BreakExpr<'a> = BreakExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<BreakExprNode<R1>> for BreakExprNode<R2> {
    fn eq(&self, other: &BreakExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for BreakExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for BreakExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for BreakExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            BREAK_EXPR => Some(BreakExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> BreakExprNode<R> {
    pub fn borrowed(&self) -> BreakExpr {
        BreakExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> BreakExprNode {
        BreakExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> BreakExpr<'a> {}

// CallExpr
#[derive(Debug, Clone, Copy,)]
pub struct CallExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type CallExpr<'a> = CallExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<CallExprNode<R1>> for CallExprNode<R2> {
    fn eq(&self, other: &CallExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for CallExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for CallExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for CallExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CALL_EXPR => Some(CallExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> CallExprNode<R> {
    pub fn borrowed(&self) -> CallExpr {
        CallExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> CallExprNode {
        CallExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::ArgListOwner<'a> for CallExpr<'a> {}
impl<'a> CallExpr<'a> {
    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// CastExpr
#[derive(Debug, Clone, Copy,)]
pub struct CastExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type CastExpr<'a> = CastExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<CastExprNode<R1>> for CastExprNode<R2> {
    fn eq(&self, other: &CastExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for CastExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for CastExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for CastExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CAST_EXPR => Some(CastExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> CastExprNode<R> {
    pub fn borrowed(&self) -> CastExpr {
        CastExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> CastExprNode {
        CastExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> CastExpr<'a> {}

// Char
#[derive(Debug, Clone, Copy,)]
pub struct CharNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Char<'a> = CharNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<CharNode<R1>> for CharNode<R2> {
    fn eq(&self, other: &CharNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for CharNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for CharNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Char<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CHAR => Some(Char { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> CharNode<R> {
    pub fn borrowed(&self) -> Char {
        CharNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> CharNode {
        CharNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Char<'a> {}

// Comment
#[derive(Debug, Clone, Copy,)]
pub struct CommentNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Comment<'a> = CommentNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<CommentNode<R1>> for CommentNode<R2> {
    fn eq(&self, other: &CommentNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for CommentNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for CommentNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Comment<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            COMMENT => Some(Comment { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> CommentNode<R> {
    pub fn borrowed(&self) -> Comment {
        CommentNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> CommentNode {
        CommentNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Comment<'a> {}

// Condition
#[derive(Debug, Clone, Copy,)]
pub struct ConditionNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Condition<'a> = ConditionNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ConditionNode<R1>> for ConditionNode<R2> {
    fn eq(&self, other: &ConditionNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ConditionNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ConditionNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Condition<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CONDITION => Some(Condition { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ConditionNode<R> {
    pub fn borrowed(&self) -> Condition {
        ConditionNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ConditionNode {
        ConditionNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Condition<'a> {
    pub fn pat(self) -> Option<Pat<'a>> {
        super::child_opt(self)
    }

    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// ConstDef
#[derive(Debug, Clone, Copy,)]
pub struct ConstDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ConstDef<'a> = ConstDefNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ConstDefNode<R1>> for ConstDefNode<R2> {
    fn eq(&self, other: &ConstDefNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ConstDefNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ConstDefNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ConstDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CONST_DEF => Some(ConstDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ConstDefNode<R> {
    pub fn borrowed(&self) -> ConstDef {
        ConstDefNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ConstDefNode {
        ConstDefNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for ConstDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for ConstDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for ConstDef<'a> {}
impl<'a> ast::DocCommentsOwner<'a> for ConstDef<'a> {}
impl<'a> ConstDef<'a> {}

// ContinueExpr
#[derive(Debug, Clone, Copy,)]
pub struct ContinueExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ContinueExpr<'a> = ContinueExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ContinueExprNode<R1>> for ContinueExprNode<R2> {
    fn eq(&self, other: &ContinueExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ContinueExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ContinueExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ContinueExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            CONTINUE_EXPR => Some(ContinueExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ContinueExprNode<R> {
    pub fn borrowed(&self) -> ContinueExpr {
        ContinueExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ContinueExprNode {
        ContinueExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ContinueExpr<'a> {}

// DynTraitType
#[derive(Debug, Clone, Copy,)]
pub struct DynTraitTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type DynTraitType<'a> = DynTraitTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<DynTraitTypeNode<R1>> for DynTraitTypeNode<R2> {
    fn eq(&self, other: &DynTraitTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for DynTraitTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for DynTraitTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for DynTraitType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            DYN_TRAIT_TYPE => Some(DynTraitType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> DynTraitTypeNode<R> {
    pub fn borrowed(&self) -> DynTraitType {
        DynTraitTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> DynTraitTypeNode {
        DynTraitTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> DynTraitType<'a> {}

// EnumDef
#[derive(Debug, Clone, Copy,)]
pub struct EnumDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type EnumDef<'a> = EnumDefNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<EnumDefNode<R1>> for EnumDefNode<R2> {
    fn eq(&self, other: &EnumDefNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for EnumDefNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for EnumDefNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for EnumDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ENUM_DEF => Some(EnumDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> EnumDefNode<R> {
    pub fn borrowed(&self) -> EnumDef {
        EnumDefNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> EnumDefNode {
        EnumDefNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for EnumDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for EnumDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for EnumDef<'a> {}
impl<'a> ast::DocCommentsOwner<'a> for EnumDef<'a> {}
impl<'a> EnumDef<'a> {}

// Expr
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Expr<'a> {
    TupleExpr(TupleExpr<'a>),
    ArrayExpr(ArrayExpr<'a>),
    ParenExpr(ParenExpr<'a>),
    PathExpr(PathExpr<'a>),
    LambdaExpr(LambdaExpr<'a>),
    IfExpr(IfExpr<'a>),
    LoopExpr(LoopExpr<'a>),
    ForExpr(ForExpr<'a>),
    WhileExpr(WhileExpr<'a>),
    ContinueExpr(ContinueExpr<'a>),
    BreakExpr(BreakExpr<'a>),
    Label(Label<'a>),
    BlockExpr(BlockExpr<'a>),
    ReturnExpr(ReturnExpr<'a>),
    MatchExpr(MatchExpr<'a>),
    MatchArmList(MatchArmList<'a>),
    MatchArm(MatchArm<'a>),
    MatchGuard(MatchGuard<'a>),
    StructLit(StructLit<'a>),
    NamedFieldList(NamedFieldList<'a>),
    NamedField(NamedField<'a>),
    CallExpr(CallExpr<'a>),
    IndexExpr(IndexExpr<'a>),
    MethodCallExpr(MethodCallExpr<'a>),
    FieldExpr(FieldExpr<'a>),
    TryExpr(TryExpr<'a>),
    CastExpr(CastExpr<'a>),
    RefExpr(RefExpr<'a>),
    PrefixExpr(PrefixExpr<'a>),
    RangeExpr(RangeExpr<'a>),
    BinExpr(BinExpr<'a>),
    Literal(Literal<'a>),
}

impl<'a> AstNode<'a> for Expr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TUPLE_EXPR => Some(Expr::TupleExpr(TupleExpr { syntax })),
            ARRAY_EXPR => Some(Expr::ArrayExpr(ArrayExpr { syntax })),
            PAREN_EXPR => Some(Expr::ParenExpr(ParenExpr { syntax })),
            PATH_EXPR => Some(Expr::PathExpr(PathExpr { syntax })),
            LAMBDA_EXPR => Some(Expr::LambdaExpr(LambdaExpr { syntax })),
            IF_EXPR => Some(Expr::IfExpr(IfExpr { syntax })),
            LOOP_EXPR => Some(Expr::LoopExpr(LoopExpr { syntax })),
            FOR_EXPR => Some(Expr::ForExpr(ForExpr { syntax })),
            WHILE_EXPR => Some(Expr::WhileExpr(WhileExpr { syntax })),
            CONTINUE_EXPR => Some(Expr::ContinueExpr(ContinueExpr { syntax })),
            BREAK_EXPR => Some(Expr::BreakExpr(BreakExpr { syntax })),
            LABEL => Some(Expr::Label(Label { syntax })),
            BLOCK_EXPR => Some(Expr::BlockExpr(BlockExpr { syntax })),
            RETURN_EXPR => Some(Expr::ReturnExpr(ReturnExpr { syntax })),
            MATCH_EXPR => Some(Expr::MatchExpr(MatchExpr { syntax })),
            MATCH_ARM_LIST => Some(Expr::MatchArmList(MatchArmList { syntax })),
            MATCH_ARM => Some(Expr::MatchArm(MatchArm { syntax })),
            MATCH_GUARD => Some(Expr::MatchGuard(MatchGuard { syntax })),
            STRUCT_LIT => Some(Expr::StructLit(StructLit { syntax })),
            NAMED_FIELD_LIST => Some(Expr::NamedFieldList(NamedFieldList { syntax })),
            NAMED_FIELD => Some(Expr::NamedField(NamedField { syntax })),
            CALL_EXPR => Some(Expr::CallExpr(CallExpr { syntax })),
            INDEX_EXPR => Some(Expr::IndexExpr(IndexExpr { syntax })),
            METHOD_CALL_EXPR => Some(Expr::MethodCallExpr(MethodCallExpr { syntax })),
            FIELD_EXPR => Some(Expr::FieldExpr(FieldExpr { syntax })),
            TRY_EXPR => Some(Expr::TryExpr(TryExpr { syntax })),
            CAST_EXPR => Some(Expr::CastExpr(CastExpr { syntax })),
            REF_EXPR => Some(Expr::RefExpr(RefExpr { syntax })),
            PREFIX_EXPR => Some(Expr::PrefixExpr(PrefixExpr { syntax })),
            RANGE_EXPR => Some(Expr::RangeExpr(RangeExpr { syntax })),
            BIN_EXPR => Some(Expr::BinExpr(BinExpr { syntax })),
            LITERAL => Some(Expr::Literal(Literal { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            Expr::TupleExpr(inner) => inner.syntax(),
            Expr::ArrayExpr(inner) => inner.syntax(),
            Expr::ParenExpr(inner) => inner.syntax(),
            Expr::PathExpr(inner) => inner.syntax(),
            Expr::LambdaExpr(inner) => inner.syntax(),
            Expr::IfExpr(inner) => inner.syntax(),
            Expr::LoopExpr(inner) => inner.syntax(),
            Expr::ForExpr(inner) => inner.syntax(),
            Expr::WhileExpr(inner) => inner.syntax(),
            Expr::ContinueExpr(inner) => inner.syntax(),
            Expr::BreakExpr(inner) => inner.syntax(),
            Expr::Label(inner) => inner.syntax(),
            Expr::BlockExpr(inner) => inner.syntax(),
            Expr::ReturnExpr(inner) => inner.syntax(),
            Expr::MatchExpr(inner) => inner.syntax(),
            Expr::MatchArmList(inner) => inner.syntax(),
            Expr::MatchArm(inner) => inner.syntax(),
            Expr::MatchGuard(inner) => inner.syntax(),
            Expr::StructLit(inner) => inner.syntax(),
            Expr::NamedFieldList(inner) => inner.syntax(),
            Expr::NamedField(inner) => inner.syntax(),
            Expr::CallExpr(inner) => inner.syntax(),
            Expr::IndexExpr(inner) => inner.syntax(),
            Expr::MethodCallExpr(inner) => inner.syntax(),
            Expr::FieldExpr(inner) => inner.syntax(),
            Expr::TryExpr(inner) => inner.syntax(),
            Expr::CastExpr(inner) => inner.syntax(),
            Expr::RefExpr(inner) => inner.syntax(),
            Expr::PrefixExpr(inner) => inner.syntax(),
            Expr::RangeExpr(inner) => inner.syntax(),
            Expr::BinExpr(inner) => inner.syntax(),
            Expr::Literal(inner) => inner.syntax(),
        }
    }
}

impl<'a> Expr<'a> {}

// ExprStmt
#[derive(Debug, Clone, Copy,)]
pub struct ExprStmtNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ExprStmt<'a> = ExprStmtNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ExprStmtNode<R1>> for ExprStmtNode<R2> {
    fn eq(&self, other: &ExprStmtNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ExprStmtNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ExprStmtNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ExprStmt<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            EXPR_STMT => Some(ExprStmt { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ExprStmtNode<R> {
    pub fn borrowed(&self) -> ExprStmt {
        ExprStmtNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ExprStmtNode {
        ExprStmtNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ExprStmt<'a> {
    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// ExternCrateItem
#[derive(Debug, Clone, Copy,)]
pub struct ExternCrateItemNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ExternCrateItem<'a> = ExternCrateItemNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ExternCrateItemNode<R1>> for ExternCrateItemNode<R2> {
    fn eq(&self, other: &ExternCrateItemNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ExternCrateItemNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ExternCrateItemNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ExternCrateItem<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            EXTERN_CRATE_ITEM => Some(ExternCrateItem { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ExternCrateItemNode<R> {
    pub fn borrowed(&self) -> ExternCrateItem {
        ExternCrateItemNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ExternCrateItemNode {
        ExternCrateItemNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ExternCrateItem<'a> {}

// FieldExpr
#[derive(Debug, Clone, Copy,)]
pub struct FieldExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type FieldExpr<'a> = FieldExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<FieldExprNode<R1>> for FieldExprNode<R2> {
    fn eq(&self, other: &FieldExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for FieldExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for FieldExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for FieldExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FIELD_EXPR => Some(FieldExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> FieldExprNode<R> {
    pub fn borrowed(&self) -> FieldExpr {
        FieldExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> FieldExprNode {
        FieldExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> FieldExpr<'a> {}

// FieldPatList
#[derive(Debug, Clone, Copy,)]
pub struct FieldPatListNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type FieldPatList<'a> = FieldPatListNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<FieldPatListNode<R1>> for FieldPatListNode<R2> {
    fn eq(&self, other: &FieldPatListNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for FieldPatListNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for FieldPatListNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for FieldPatList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FIELD_PAT_LIST => Some(FieldPatList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> FieldPatListNode<R> {
    pub fn borrowed(&self) -> FieldPatList {
        FieldPatListNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> FieldPatListNode {
        FieldPatListNode { syntax: self.syntax.owned() }
    }
}


impl<'a> FieldPatList<'a> {}

// FnDef
#[derive(Debug, Clone, Copy,)]
pub struct FnDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type FnDef<'a> = FnDefNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<FnDefNode<R1>> for FnDefNode<R2> {
    fn eq(&self, other: &FnDefNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for FnDefNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for FnDefNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for FnDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FN_DEF => Some(FnDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> FnDefNode<R> {
    pub fn borrowed(&self) -> FnDef {
        FnDefNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> FnDefNode {
        FnDefNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for FnDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for FnDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for FnDef<'a> {}
impl<'a> ast::DocCommentsOwner<'a> for FnDef<'a> {}
impl<'a> FnDef<'a> {
    pub fn param_list(self) -> Option<ParamList<'a>> {
        super::child_opt(self)
    }

    pub fn body(self) -> Option<Block<'a>> {
        super::child_opt(self)
    }

    pub fn ret_type(self) -> Option<RetType<'a>> {
        super::child_opt(self)
    }
}

// FnPointerType
#[derive(Debug, Clone, Copy,)]
pub struct FnPointerTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type FnPointerType<'a> = FnPointerTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<FnPointerTypeNode<R1>> for FnPointerTypeNode<R2> {
    fn eq(&self, other: &FnPointerTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for FnPointerTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for FnPointerTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for FnPointerType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FN_POINTER_TYPE => Some(FnPointerType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> FnPointerTypeNode<R> {
    pub fn borrowed(&self) -> FnPointerType {
        FnPointerTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> FnPointerTypeNode {
        FnPointerTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> FnPointerType<'a> {}

// ForExpr
#[derive(Debug, Clone, Copy,)]
pub struct ForExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ForExpr<'a> = ForExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ForExprNode<R1>> for ForExprNode<R2> {
    fn eq(&self, other: &ForExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ForExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ForExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ForExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FOR_EXPR => Some(ForExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ForExprNode<R> {
    pub fn borrowed(&self) -> ForExpr {
        ForExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ForExprNode {
        ForExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::LoopBodyOwner<'a> for ForExpr<'a> {}
impl<'a> ForExpr<'a> {
    pub fn pat(self) -> Option<Pat<'a>> {
        super::child_opt(self)
    }

    pub fn iterable(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// ForType
#[derive(Debug, Clone, Copy,)]
pub struct ForTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ForType<'a> = ForTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ForTypeNode<R1>> for ForTypeNode<R2> {
    fn eq(&self, other: &ForTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ForTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ForTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ForType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            FOR_TYPE => Some(ForType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ForTypeNode<R> {
    pub fn borrowed(&self) -> ForType {
        ForTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ForTypeNode {
        ForTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ForType<'a> {}

// IfExpr
#[derive(Debug, Clone, Copy,)]
pub struct IfExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type IfExpr<'a> = IfExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<IfExprNode<R1>> for IfExprNode<R2> {
    fn eq(&self, other: &IfExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for IfExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for IfExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for IfExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            IF_EXPR => Some(IfExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> IfExprNode<R> {
    pub fn borrowed(&self) -> IfExpr {
        IfExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> IfExprNode {
        IfExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> IfExpr<'a> {
    pub fn condition(self) -> Option<Condition<'a>> {
        super::child_opt(self)
    }
}

// ImplItem
#[derive(Debug, Clone, Copy,)]
pub struct ImplItemNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ImplItem<'a> = ImplItemNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ImplItemNode<R1>> for ImplItemNode<R2> {
    fn eq(&self, other: &ImplItemNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ImplItemNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ImplItemNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ImplItem<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            IMPL_ITEM => Some(ImplItem { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ImplItemNode<R> {
    pub fn borrowed(&self) -> ImplItem {
        ImplItemNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ImplItemNode {
        ImplItemNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ImplItem<'a> {}

// ImplTraitType
#[derive(Debug, Clone, Copy,)]
pub struct ImplTraitTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ImplTraitType<'a> = ImplTraitTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ImplTraitTypeNode<R1>> for ImplTraitTypeNode<R2> {
    fn eq(&self, other: &ImplTraitTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ImplTraitTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ImplTraitTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ImplTraitType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            IMPL_TRAIT_TYPE => Some(ImplTraitType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ImplTraitTypeNode<R> {
    pub fn borrowed(&self) -> ImplTraitType {
        ImplTraitTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ImplTraitTypeNode {
        ImplTraitTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ImplTraitType<'a> {}

// IndexExpr
#[derive(Debug, Clone, Copy,)]
pub struct IndexExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type IndexExpr<'a> = IndexExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<IndexExprNode<R1>> for IndexExprNode<R2> {
    fn eq(&self, other: &IndexExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for IndexExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for IndexExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for IndexExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            INDEX_EXPR => Some(IndexExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> IndexExprNode<R> {
    pub fn borrowed(&self) -> IndexExpr {
        IndexExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> IndexExprNode {
        IndexExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> IndexExpr<'a> {}

// ItemList
#[derive(Debug, Clone, Copy,)]
pub struct ItemListNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ItemList<'a> = ItemListNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ItemListNode<R1>> for ItemListNode<R2> {
    fn eq(&self, other: &ItemListNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ItemListNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ItemListNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ItemList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ITEM_LIST => Some(ItemList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ItemListNode<R> {
    pub fn borrowed(&self) -> ItemList {
        ItemListNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ItemListNode {
        ItemListNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::FnDefOwner<'a> for ItemList<'a> {}
impl<'a> ast::ModuleItemOwner<'a> for ItemList<'a> {}
impl<'a> ItemList<'a> {}

// Label
#[derive(Debug, Clone, Copy,)]
pub struct LabelNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Label<'a> = LabelNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LabelNode<R1>> for LabelNode<R2> {
    fn eq(&self, other: &LabelNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for LabelNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for LabelNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Label<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LABEL => Some(Label { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> LabelNode<R> {
    pub fn borrowed(&self) -> Label {
        LabelNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> LabelNode {
        LabelNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Label<'a> {}

// LambdaExpr
#[derive(Debug, Clone, Copy,)]
pub struct LambdaExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type LambdaExpr<'a> = LambdaExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LambdaExprNode<R1>> for LambdaExprNode<R2> {
    fn eq(&self, other: &LambdaExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for LambdaExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for LambdaExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for LambdaExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LAMBDA_EXPR => Some(LambdaExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> LambdaExprNode<R> {
    pub fn borrowed(&self) -> LambdaExpr {
        LambdaExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> LambdaExprNode {
        LambdaExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> LambdaExpr<'a> {
    pub fn param_list(self) -> Option<ParamList<'a>> {
        super::child_opt(self)
    }

    pub fn body(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// LetStmt
#[derive(Debug, Clone, Copy,)]
pub struct LetStmtNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type LetStmt<'a> = LetStmtNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LetStmtNode<R1>> for LetStmtNode<R2> {
    fn eq(&self, other: &LetStmtNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for LetStmtNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for LetStmtNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for LetStmt<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LET_STMT => Some(LetStmt { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> LetStmtNode<R> {
    pub fn borrowed(&self) -> LetStmt {
        LetStmtNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> LetStmtNode {
        LetStmtNode { syntax: self.syntax.owned() }
    }
}


impl<'a> LetStmt<'a> {
    pub fn pat(self) -> Option<Pat<'a>> {
        super::child_opt(self)
    }

    pub fn initializer(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// Lifetime
#[derive(Debug, Clone, Copy,)]
pub struct LifetimeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Lifetime<'a> = LifetimeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LifetimeNode<R1>> for LifetimeNode<R2> {
    fn eq(&self, other: &LifetimeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for LifetimeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for LifetimeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Lifetime<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LIFETIME => Some(Lifetime { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> LifetimeNode<R> {
    pub fn borrowed(&self) -> Lifetime {
        LifetimeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> LifetimeNode {
        LifetimeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Lifetime<'a> {}

// LifetimeParam
#[derive(Debug, Clone, Copy,)]
pub struct LifetimeParamNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type LifetimeParam<'a> = LifetimeParamNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LifetimeParamNode<R1>> for LifetimeParamNode<R2> {
    fn eq(&self, other: &LifetimeParamNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for LifetimeParamNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for LifetimeParamNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for LifetimeParam<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LIFETIME_PARAM => Some(LifetimeParam { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> LifetimeParamNode<R> {
    pub fn borrowed(&self) -> LifetimeParam {
        LifetimeParamNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> LifetimeParamNode {
        LifetimeParamNode { syntax: self.syntax.owned() }
    }
}


impl<'a> LifetimeParam<'a> {
    pub fn lifetime(self) -> Option<Lifetime<'a>> {
        super::child_opt(self)
    }
}

// Literal
#[derive(Debug, Clone, Copy,)]
pub struct LiteralNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Literal<'a> = LiteralNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LiteralNode<R1>> for LiteralNode<R2> {
    fn eq(&self, other: &LiteralNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for LiteralNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for LiteralNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Literal<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LITERAL => Some(Literal { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> LiteralNode<R> {
    pub fn borrowed(&self) -> Literal {
        LiteralNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> LiteralNode {
        LiteralNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Literal<'a> {}

// LoopExpr
#[derive(Debug, Clone, Copy,)]
pub struct LoopExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type LoopExpr<'a> = LoopExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LoopExprNode<R1>> for LoopExprNode<R2> {
    fn eq(&self, other: &LoopExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for LoopExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for LoopExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for LoopExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            LOOP_EXPR => Some(LoopExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> LoopExprNode<R> {
    pub fn borrowed(&self) -> LoopExpr {
        LoopExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> LoopExprNode {
        LoopExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::LoopBodyOwner<'a> for LoopExpr<'a> {}
impl<'a> LoopExpr<'a> {}

// MatchArm
#[derive(Debug, Clone, Copy,)]
pub struct MatchArmNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type MatchArm<'a> = MatchArmNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<MatchArmNode<R1>> for MatchArmNode<R2> {
    fn eq(&self, other: &MatchArmNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for MatchArmNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for MatchArmNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for MatchArm<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            MATCH_ARM => Some(MatchArm { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> MatchArmNode<R> {
    pub fn borrowed(&self) -> MatchArm {
        MatchArmNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> MatchArmNode {
        MatchArmNode { syntax: self.syntax.owned() }
    }
}


impl<'a> MatchArm<'a> {
    pub fn pats(self) -> impl Iterator<Item = Pat<'a>> + 'a {
        super::children(self)
    }

    pub fn guard(self) -> Option<MatchGuard<'a>> {
        super::child_opt(self)
    }

    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// MatchArmList
#[derive(Debug, Clone, Copy,)]
pub struct MatchArmListNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type MatchArmList<'a> = MatchArmListNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<MatchArmListNode<R1>> for MatchArmListNode<R2> {
    fn eq(&self, other: &MatchArmListNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for MatchArmListNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for MatchArmListNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for MatchArmList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            MATCH_ARM_LIST => Some(MatchArmList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> MatchArmListNode<R> {
    pub fn borrowed(&self) -> MatchArmList {
        MatchArmListNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> MatchArmListNode {
        MatchArmListNode { syntax: self.syntax.owned() }
    }
}


impl<'a> MatchArmList<'a> {
    pub fn arms(self) -> impl Iterator<Item = MatchArm<'a>> + 'a {
        super::children(self)
    }
}

// MatchExpr
#[derive(Debug, Clone, Copy,)]
pub struct MatchExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type MatchExpr<'a> = MatchExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<MatchExprNode<R1>> for MatchExprNode<R2> {
    fn eq(&self, other: &MatchExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for MatchExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for MatchExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for MatchExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            MATCH_EXPR => Some(MatchExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> MatchExprNode<R> {
    pub fn borrowed(&self) -> MatchExpr {
        MatchExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> MatchExprNode {
        MatchExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> MatchExpr<'a> {
    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }

    pub fn match_arm_list(self) -> Option<MatchArmList<'a>> {
        super::child_opt(self)
    }
}

// MatchGuard
#[derive(Debug, Clone, Copy,)]
pub struct MatchGuardNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type MatchGuard<'a> = MatchGuardNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<MatchGuardNode<R1>> for MatchGuardNode<R2> {
    fn eq(&self, other: &MatchGuardNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for MatchGuardNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for MatchGuardNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for MatchGuard<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            MATCH_GUARD => Some(MatchGuard { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> MatchGuardNode<R> {
    pub fn borrowed(&self) -> MatchGuard {
        MatchGuardNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> MatchGuardNode {
        MatchGuardNode { syntax: self.syntax.owned() }
    }
}


impl<'a> MatchGuard<'a> {}

// MethodCallExpr
#[derive(Debug, Clone, Copy,)]
pub struct MethodCallExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type MethodCallExpr<'a> = MethodCallExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<MethodCallExprNode<R1>> for MethodCallExprNode<R2> {
    fn eq(&self, other: &MethodCallExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for MethodCallExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for MethodCallExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for MethodCallExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            METHOD_CALL_EXPR => Some(MethodCallExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> MethodCallExprNode<R> {
    pub fn borrowed(&self) -> MethodCallExpr {
        MethodCallExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> MethodCallExprNode {
        MethodCallExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::ArgListOwner<'a> for MethodCallExpr<'a> {}
impl<'a> MethodCallExpr<'a> {
    pub fn expr(self) -> Option<Expr<'a>> {
        super::child_opt(self)
    }
}

// Module
#[derive(Debug, Clone, Copy,)]
pub struct ModuleNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Module<'a> = ModuleNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ModuleNode<R1>> for ModuleNode<R2> {
    fn eq(&self, other: &ModuleNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ModuleNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ModuleNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Module<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            MODULE => Some(Module { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ModuleNode<R> {
    pub fn borrowed(&self) -> Module {
        ModuleNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ModuleNode {
        ModuleNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for Module<'a> {}
impl<'a> ast::AttrsOwner<'a> for Module<'a> {}
impl<'a> ast::DocCommentsOwner<'a> for Module<'a> {}
impl<'a> Module<'a> {
    pub fn item_list(self) -> Option<ItemList<'a>> {
        super::child_opt(self)
    }
}

// ModuleItem
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ModuleItem<'a> {
    StructDef(StructDef<'a>),
    EnumDef(EnumDef<'a>),
    FnDef(FnDef<'a>),
    TraitDef(TraitDef<'a>),
    TypeDef(TypeDef<'a>),
    ImplItem(ImplItem<'a>),
    UseItem(UseItem<'a>),
    ExternCrateItem(ExternCrateItem<'a>),
    ConstDef(ConstDef<'a>),
    StaticDef(StaticDef<'a>),
    Module(Module<'a>),
}

impl<'a> AstNode<'a> for ModuleItem<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STRUCT_DEF => Some(ModuleItem::StructDef(StructDef { syntax })),
            ENUM_DEF => Some(ModuleItem::EnumDef(EnumDef { syntax })),
            FN_DEF => Some(ModuleItem::FnDef(FnDef { syntax })),
            TRAIT_DEF => Some(ModuleItem::TraitDef(TraitDef { syntax })),
            TYPE_DEF => Some(ModuleItem::TypeDef(TypeDef { syntax })),
            IMPL_ITEM => Some(ModuleItem::ImplItem(ImplItem { syntax })),
            USE_ITEM => Some(ModuleItem::UseItem(UseItem { syntax })),
            EXTERN_CRATE_ITEM => Some(ModuleItem::ExternCrateItem(ExternCrateItem { syntax })),
            CONST_DEF => Some(ModuleItem::ConstDef(ConstDef { syntax })),
            STATIC_DEF => Some(ModuleItem::StaticDef(StaticDef { syntax })),
            MODULE => Some(ModuleItem::Module(Module { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            ModuleItem::StructDef(inner) => inner.syntax(),
            ModuleItem::EnumDef(inner) => inner.syntax(),
            ModuleItem::FnDef(inner) => inner.syntax(),
            ModuleItem::TraitDef(inner) => inner.syntax(),
            ModuleItem::TypeDef(inner) => inner.syntax(),
            ModuleItem::ImplItem(inner) => inner.syntax(),
            ModuleItem::UseItem(inner) => inner.syntax(),
            ModuleItem::ExternCrateItem(inner) => inner.syntax(),
            ModuleItem::ConstDef(inner) => inner.syntax(),
            ModuleItem::StaticDef(inner) => inner.syntax(),
            ModuleItem::Module(inner) => inner.syntax(),
        }
    }
}

impl<'a> ModuleItem<'a> {}

// Name
#[derive(Debug, Clone, Copy,)]
pub struct NameNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Name<'a> = NameNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NameNode<R1>> for NameNode<R2> {
    fn eq(&self, other: &NameNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for NameNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for NameNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Name<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NAME => Some(Name { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> NameNode<R> {
    pub fn borrowed(&self) -> Name {
        NameNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> NameNode {
        NameNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Name<'a> {}

// NameRef
#[derive(Debug, Clone, Copy,)]
pub struct NameRefNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type NameRef<'a> = NameRefNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NameRefNode<R1>> for NameRefNode<R2> {
    fn eq(&self, other: &NameRefNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for NameRefNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for NameRefNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for NameRef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NAME_REF => Some(NameRef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> NameRefNode<R> {
    pub fn borrowed(&self) -> NameRef {
        NameRefNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> NameRefNode {
        NameRefNode { syntax: self.syntax.owned() }
    }
}


impl<'a> NameRef<'a> {}

// NamedField
#[derive(Debug, Clone, Copy,)]
pub struct NamedFieldNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type NamedField<'a> = NamedFieldNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NamedFieldNode<R1>> for NamedFieldNode<R2> {
    fn eq(&self, other: &NamedFieldNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for NamedFieldNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for NamedFieldNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for NamedField<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NAMED_FIELD => Some(NamedField { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> NamedFieldNode<R> {
    pub fn borrowed(&self) -> NamedField {
        NamedFieldNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> NamedFieldNode {
        NamedFieldNode { syntax: self.syntax.owned() }
    }
}


impl<'a> NamedField<'a> {}

// NamedFieldDef
#[derive(Debug, Clone, Copy,)]
pub struct NamedFieldDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type NamedFieldDef<'a> = NamedFieldDefNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NamedFieldDefNode<R1>> for NamedFieldDefNode<R2> {
    fn eq(&self, other: &NamedFieldDefNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for NamedFieldDefNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for NamedFieldDefNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for NamedFieldDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NAMED_FIELD_DEF => Some(NamedFieldDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> NamedFieldDefNode<R> {
    pub fn borrowed(&self) -> NamedFieldDef {
        NamedFieldDefNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> NamedFieldDefNode {
        NamedFieldDefNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for NamedFieldDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for NamedFieldDef<'a> {}
impl<'a> NamedFieldDef<'a> {}

// NamedFieldList
#[derive(Debug, Clone, Copy,)]
pub struct NamedFieldListNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type NamedFieldList<'a> = NamedFieldListNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NamedFieldListNode<R1>> for NamedFieldListNode<R2> {
    fn eq(&self, other: &NamedFieldListNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for NamedFieldListNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for NamedFieldListNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for NamedFieldList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NAMED_FIELD_LIST => Some(NamedFieldList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> NamedFieldListNode<R> {
    pub fn borrowed(&self) -> NamedFieldList {
        NamedFieldListNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> NamedFieldListNode {
        NamedFieldListNode { syntax: self.syntax.owned() }
    }
}


impl<'a> NamedFieldList<'a> {}

// NeverType
#[derive(Debug, Clone, Copy,)]
pub struct NeverTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type NeverType<'a> = NeverTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NeverTypeNode<R1>> for NeverTypeNode<R2> {
    fn eq(&self, other: &NeverTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for NeverTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for NeverTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for NeverType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            NEVER_TYPE => Some(NeverType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> NeverTypeNode<R> {
    pub fn borrowed(&self) -> NeverType {
        NeverTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> NeverTypeNode {
        NeverTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> NeverType<'a> {}

// NominalDef
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NominalDef<'a> {
    StructDef(StructDef<'a>),
    EnumDef(EnumDef<'a>),
}

impl<'a> AstNode<'a> for NominalDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STRUCT_DEF => Some(NominalDef::StructDef(StructDef { syntax })),
            ENUM_DEF => Some(NominalDef::EnumDef(EnumDef { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            NominalDef::StructDef(inner) => inner.syntax(),
            NominalDef::EnumDef(inner) => inner.syntax(),
        }
    }
}

impl<'a> ast::NameOwner<'a> for NominalDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for NominalDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for NominalDef<'a> {}
impl<'a> NominalDef<'a> {}

// Param
#[derive(Debug, Clone, Copy,)]
pub struct ParamNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Param<'a> = ParamNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ParamNode<R1>> for ParamNode<R2> {
    fn eq(&self, other: &ParamNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ParamNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ParamNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Param<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PARAM => Some(Param { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ParamNode<R> {
    pub fn borrowed(&self) -> Param {
        ParamNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ParamNode {
        ParamNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Param<'a> {
    pub fn pat(self) -> Option<Pat<'a>> {
        super::child_opt(self)
    }
}

// ParamList
#[derive(Debug, Clone, Copy,)]
pub struct ParamListNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ParamList<'a> = ParamListNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ParamListNode<R1>> for ParamListNode<R2> {
    fn eq(&self, other: &ParamListNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ParamListNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ParamListNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ParamList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PARAM_LIST => Some(ParamList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ParamListNode<R> {
    pub fn borrowed(&self) -> ParamList {
        ParamListNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ParamListNode {
        ParamListNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ParamList<'a> {
    pub fn params(self) -> impl Iterator<Item = Param<'a>> + 'a {
        super::children(self)
    }

    pub fn self_param(self) -> Option<SelfParam<'a>> {
        super::child_opt(self)
    }
}

// ParenExpr
#[derive(Debug, Clone, Copy,)]
pub struct ParenExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ParenExpr<'a> = ParenExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ParenExprNode<R1>> for ParenExprNode<R2> {
    fn eq(&self, other: &ParenExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ParenExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ParenExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ParenExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PAREN_EXPR => Some(ParenExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ParenExprNode<R> {
    pub fn borrowed(&self) -> ParenExpr {
        ParenExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ParenExprNode {
        ParenExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ParenExpr<'a> {}

// ParenType
#[derive(Debug, Clone, Copy,)]
pub struct ParenTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ParenType<'a> = ParenTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ParenTypeNode<R1>> for ParenTypeNode<R2> {
    fn eq(&self, other: &ParenTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ParenTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ParenTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ParenType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PAREN_TYPE => Some(ParenType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ParenTypeNode<R> {
    pub fn borrowed(&self) -> ParenType {
        ParenTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ParenTypeNode {
        ParenTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ParenType<'a> {}

// Pat
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Pat<'a> {
    RefPat(RefPat<'a>),
    BindPat(BindPat<'a>),
    PlaceholderPat(PlaceholderPat<'a>),
    PathPat(PathPat<'a>),
    StructPat(StructPat<'a>),
    FieldPatList(FieldPatList<'a>),
    TupleStructPat(TupleStructPat<'a>),
    TuplePat(TuplePat<'a>),
    SlicePat(SlicePat<'a>),
    RangePat(RangePat<'a>),
}

impl<'a> AstNode<'a> for Pat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            REF_PAT => Some(Pat::RefPat(RefPat { syntax })),
            BIND_PAT => Some(Pat::BindPat(BindPat { syntax })),
            PLACEHOLDER_PAT => Some(Pat::PlaceholderPat(PlaceholderPat { syntax })),
            PATH_PAT => Some(Pat::PathPat(PathPat { syntax })),
            STRUCT_PAT => Some(Pat::StructPat(StructPat { syntax })),
            FIELD_PAT_LIST => Some(Pat::FieldPatList(FieldPatList { syntax })),
            TUPLE_STRUCT_PAT => Some(Pat::TupleStructPat(TupleStructPat { syntax })),
            TUPLE_PAT => Some(Pat::TuplePat(TuplePat { syntax })),
            SLICE_PAT => Some(Pat::SlicePat(SlicePat { syntax })),
            RANGE_PAT => Some(Pat::RangePat(RangePat { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            Pat::RefPat(inner) => inner.syntax(),
            Pat::BindPat(inner) => inner.syntax(),
            Pat::PlaceholderPat(inner) => inner.syntax(),
            Pat::PathPat(inner) => inner.syntax(),
            Pat::StructPat(inner) => inner.syntax(),
            Pat::FieldPatList(inner) => inner.syntax(),
            Pat::TupleStructPat(inner) => inner.syntax(),
            Pat::TuplePat(inner) => inner.syntax(),
            Pat::SlicePat(inner) => inner.syntax(),
            Pat::RangePat(inner) => inner.syntax(),
        }
    }
}

impl<'a> Pat<'a> {}

// Path
#[derive(Debug, Clone, Copy,)]
pub struct PathNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Path<'a> = PathNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PathNode<R1>> for PathNode<R2> {
    fn eq(&self, other: &PathNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for PathNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for PathNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Path<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PATH => Some(Path { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> PathNode<R> {
    pub fn borrowed(&self) -> Path {
        PathNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> PathNode {
        PathNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Path<'a> {
    pub fn segment(self) -> Option<PathSegment<'a>> {
        super::child_opt(self)
    }

    pub fn qualifier(self) -> Option<Path<'a>> {
        super::child_opt(self)
    }
}

// PathExpr
#[derive(Debug, Clone, Copy,)]
pub struct PathExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type PathExpr<'a> = PathExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PathExprNode<R1>> for PathExprNode<R2> {
    fn eq(&self, other: &PathExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for PathExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for PathExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for PathExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PATH_EXPR => Some(PathExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> PathExprNode<R> {
    pub fn borrowed(&self) -> PathExpr {
        PathExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> PathExprNode {
        PathExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> PathExpr<'a> {
    pub fn path(self) -> Option<Path<'a>> {
        super::child_opt(self)
    }
}

// PathPat
#[derive(Debug, Clone, Copy,)]
pub struct PathPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type PathPat<'a> = PathPatNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PathPatNode<R1>> for PathPatNode<R2> {
    fn eq(&self, other: &PathPatNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for PathPatNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for PathPatNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for PathPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PATH_PAT => Some(PathPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> PathPatNode<R> {
    pub fn borrowed(&self) -> PathPat {
        PathPatNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> PathPatNode {
        PathPatNode { syntax: self.syntax.owned() }
    }
}


impl<'a> PathPat<'a> {}

// PathSegment
#[derive(Debug, Clone, Copy,)]
pub struct PathSegmentNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type PathSegment<'a> = PathSegmentNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PathSegmentNode<R1>> for PathSegmentNode<R2> {
    fn eq(&self, other: &PathSegmentNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for PathSegmentNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for PathSegmentNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for PathSegment<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PATH_SEGMENT => Some(PathSegment { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> PathSegmentNode<R> {
    pub fn borrowed(&self) -> PathSegment {
        PathSegmentNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> PathSegmentNode {
        PathSegmentNode { syntax: self.syntax.owned() }
    }
}


impl<'a> PathSegment<'a> {
    pub fn name_ref(self) -> Option<NameRef<'a>> {
        super::child_opt(self)
    }
}

// PathType
#[derive(Debug, Clone, Copy,)]
pub struct PathTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type PathType<'a> = PathTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PathTypeNode<R1>> for PathTypeNode<R2> {
    fn eq(&self, other: &PathTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for PathTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for PathTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for PathType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PATH_TYPE => Some(PathType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> PathTypeNode<R> {
    pub fn borrowed(&self) -> PathType {
        PathTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> PathTypeNode {
        PathTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> PathType<'a> {}

// PlaceholderPat
#[derive(Debug, Clone, Copy,)]
pub struct PlaceholderPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type PlaceholderPat<'a> = PlaceholderPatNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PlaceholderPatNode<R1>> for PlaceholderPatNode<R2> {
    fn eq(&self, other: &PlaceholderPatNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for PlaceholderPatNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for PlaceholderPatNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for PlaceholderPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PLACEHOLDER_PAT => Some(PlaceholderPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> PlaceholderPatNode<R> {
    pub fn borrowed(&self) -> PlaceholderPat {
        PlaceholderPatNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> PlaceholderPatNode {
        PlaceholderPatNode { syntax: self.syntax.owned() }
    }
}


impl<'a> PlaceholderPat<'a> {}

// PlaceholderType
#[derive(Debug, Clone, Copy,)]
pub struct PlaceholderTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type PlaceholderType<'a> = PlaceholderTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PlaceholderTypeNode<R1>> for PlaceholderTypeNode<R2> {
    fn eq(&self, other: &PlaceholderTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for PlaceholderTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for PlaceholderTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for PlaceholderType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PLACEHOLDER_TYPE => Some(PlaceholderType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> PlaceholderTypeNode<R> {
    pub fn borrowed(&self) -> PlaceholderType {
        PlaceholderTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> PlaceholderTypeNode {
        PlaceholderTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> PlaceholderType<'a> {}

// PointerType
#[derive(Debug, Clone, Copy,)]
pub struct PointerTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type PointerType<'a> = PointerTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PointerTypeNode<R1>> for PointerTypeNode<R2> {
    fn eq(&self, other: &PointerTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for PointerTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for PointerTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for PointerType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            POINTER_TYPE => Some(PointerType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> PointerTypeNode<R> {
    pub fn borrowed(&self) -> PointerType {
        PointerTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> PointerTypeNode {
        PointerTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> PointerType<'a> {}

// PrefixExpr
#[derive(Debug, Clone, Copy,)]
pub struct PrefixExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type PrefixExpr<'a> = PrefixExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PrefixExprNode<R1>> for PrefixExprNode<R2> {
    fn eq(&self, other: &PrefixExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for PrefixExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for PrefixExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for PrefixExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PREFIX_EXPR => Some(PrefixExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> PrefixExprNode<R> {
    pub fn borrowed(&self) -> PrefixExpr {
        PrefixExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> PrefixExprNode {
        PrefixExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> PrefixExpr<'a> {}

// RangeExpr
#[derive(Debug, Clone, Copy,)]
pub struct RangeExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type RangeExpr<'a> = RangeExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RangeExprNode<R1>> for RangeExprNode<R2> {
    fn eq(&self, other: &RangeExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for RangeExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for RangeExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for RangeExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            RANGE_EXPR => Some(RangeExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> RangeExprNode<R> {
    pub fn borrowed(&self) -> RangeExpr {
        RangeExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> RangeExprNode {
        RangeExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> RangeExpr<'a> {}

// RangePat
#[derive(Debug, Clone, Copy,)]
pub struct RangePatNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type RangePat<'a> = RangePatNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RangePatNode<R1>> for RangePatNode<R2> {
    fn eq(&self, other: &RangePatNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for RangePatNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for RangePatNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for RangePat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            RANGE_PAT => Some(RangePat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> RangePatNode<R> {
    pub fn borrowed(&self) -> RangePat {
        RangePatNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> RangePatNode {
        RangePatNode { syntax: self.syntax.owned() }
    }
}


impl<'a> RangePat<'a> {}

// RefExpr
#[derive(Debug, Clone, Copy,)]
pub struct RefExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type RefExpr<'a> = RefExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RefExprNode<R1>> for RefExprNode<R2> {
    fn eq(&self, other: &RefExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for RefExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for RefExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for RefExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            REF_EXPR => Some(RefExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> RefExprNode<R> {
    pub fn borrowed(&self) -> RefExpr {
        RefExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> RefExprNode {
        RefExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> RefExpr<'a> {}

// RefPat
#[derive(Debug, Clone, Copy,)]
pub struct RefPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type RefPat<'a> = RefPatNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RefPatNode<R1>> for RefPatNode<R2> {
    fn eq(&self, other: &RefPatNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for RefPatNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for RefPatNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for RefPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            REF_PAT => Some(RefPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> RefPatNode<R> {
    pub fn borrowed(&self) -> RefPat {
        RefPatNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> RefPatNode {
        RefPatNode { syntax: self.syntax.owned() }
    }
}


impl<'a> RefPat<'a> {}

// ReferenceType
#[derive(Debug, Clone, Copy,)]
pub struct ReferenceTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ReferenceType<'a> = ReferenceTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ReferenceTypeNode<R1>> for ReferenceTypeNode<R2> {
    fn eq(&self, other: &ReferenceTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ReferenceTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ReferenceTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ReferenceType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            REFERENCE_TYPE => Some(ReferenceType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ReferenceTypeNode<R> {
    pub fn borrowed(&self) -> ReferenceType {
        ReferenceTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ReferenceTypeNode {
        ReferenceTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ReferenceType<'a> {}

// RetType
#[derive(Debug, Clone, Copy,)]
pub struct RetTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type RetType<'a> = RetTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RetTypeNode<R1>> for RetTypeNode<R2> {
    fn eq(&self, other: &RetTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for RetTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for RetTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for RetType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            RET_TYPE => Some(RetType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> RetTypeNode<R> {
    pub fn borrowed(&self) -> RetType {
        RetTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> RetTypeNode {
        RetTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> RetType<'a> {}

// ReturnExpr
#[derive(Debug, Clone, Copy,)]
pub struct ReturnExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type ReturnExpr<'a> = ReturnExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ReturnExprNode<R1>> for ReturnExprNode<R2> {
    fn eq(&self, other: &ReturnExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for ReturnExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for ReturnExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for ReturnExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            RETURN_EXPR => Some(ReturnExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> ReturnExprNode<R> {
    pub fn borrowed(&self) -> ReturnExpr {
        ReturnExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> ReturnExprNode {
        ReturnExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ReturnExpr<'a> {}

// Root
#[derive(Debug, Clone, Copy,)]
pub struct RootNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Root<'a> = RootNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RootNode<R1>> for RootNode<R2> {
    fn eq(&self, other: &RootNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for RootNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for RootNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Root<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            ROOT => Some(Root { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> RootNode<R> {
    pub fn borrowed(&self) -> Root {
        RootNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> RootNode {
        RootNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::ModuleItemOwner<'a> for Root<'a> {}
impl<'a> ast::FnDefOwner<'a> for Root<'a> {}
impl<'a> Root<'a> {
    pub fn modules(self) -> impl Iterator<Item = Module<'a>> + 'a {
        super::children(self)
    }
}

// SelfParam
#[derive(Debug, Clone, Copy,)]
pub struct SelfParamNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type SelfParam<'a> = SelfParamNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<SelfParamNode<R1>> for SelfParamNode<R2> {
    fn eq(&self, other: &SelfParamNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for SelfParamNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for SelfParamNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for SelfParam<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            SELF_PARAM => Some(SelfParam { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> SelfParamNode<R> {
    pub fn borrowed(&self) -> SelfParam {
        SelfParamNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> SelfParamNode {
        SelfParamNode { syntax: self.syntax.owned() }
    }
}


impl<'a> SelfParam<'a> {}

// SlicePat
#[derive(Debug, Clone, Copy,)]
pub struct SlicePatNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type SlicePat<'a> = SlicePatNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<SlicePatNode<R1>> for SlicePatNode<R2> {
    fn eq(&self, other: &SlicePatNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for SlicePatNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for SlicePatNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for SlicePat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            SLICE_PAT => Some(SlicePat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> SlicePatNode<R> {
    pub fn borrowed(&self) -> SlicePat {
        SlicePatNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> SlicePatNode {
        SlicePatNode { syntax: self.syntax.owned() }
    }
}


impl<'a> SlicePat<'a> {}

// SliceType
#[derive(Debug, Clone, Copy,)]
pub struct SliceTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type SliceType<'a> = SliceTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<SliceTypeNode<R1>> for SliceTypeNode<R2> {
    fn eq(&self, other: &SliceTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for SliceTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for SliceTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for SliceType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            SLICE_TYPE => Some(SliceType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> SliceTypeNode<R> {
    pub fn borrowed(&self) -> SliceType {
        SliceTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> SliceTypeNode {
        SliceTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> SliceType<'a> {}

// StaticDef
#[derive(Debug, Clone, Copy,)]
pub struct StaticDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type StaticDef<'a> = StaticDefNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<StaticDefNode<R1>> for StaticDefNode<R2> {
    fn eq(&self, other: &StaticDefNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for StaticDefNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for StaticDefNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for StaticDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STATIC_DEF => Some(StaticDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> StaticDefNode<R> {
    pub fn borrowed(&self) -> StaticDef {
        StaticDefNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> StaticDefNode {
        StaticDefNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for StaticDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for StaticDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for StaticDef<'a> {}
impl<'a> ast::DocCommentsOwner<'a> for StaticDef<'a> {}
impl<'a> StaticDef<'a> {}

// Stmt
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Stmt<'a> {
    ExprStmt(ExprStmt<'a>),
    LetStmt(LetStmt<'a>),
}

impl<'a> AstNode<'a> for Stmt<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            EXPR_STMT => Some(Stmt::ExprStmt(ExprStmt { syntax })),
            LET_STMT => Some(Stmt::LetStmt(LetStmt { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            Stmt::ExprStmt(inner) => inner.syntax(),
            Stmt::LetStmt(inner) => inner.syntax(),
        }
    }
}

impl<'a> Stmt<'a> {}

// StructDef
#[derive(Debug, Clone, Copy,)]
pub struct StructDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type StructDef<'a> = StructDefNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<StructDefNode<R1>> for StructDefNode<R2> {
    fn eq(&self, other: &StructDefNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for StructDefNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for StructDefNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for StructDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STRUCT_DEF => Some(StructDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> StructDefNode<R> {
    pub fn borrowed(&self) -> StructDef {
        StructDefNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> StructDefNode {
        StructDefNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for StructDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for StructDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for StructDef<'a> {}
impl<'a> ast::DocCommentsOwner<'a> for StructDef<'a> {}
impl<'a> StructDef<'a> {
    pub fn fields(self) -> impl Iterator<Item = NamedFieldDef<'a>> + 'a {
        super::children(self)
    }
}

// StructLit
#[derive(Debug, Clone, Copy,)]
pub struct StructLitNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type StructLit<'a> = StructLitNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<StructLitNode<R1>> for StructLitNode<R2> {
    fn eq(&self, other: &StructLitNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for StructLitNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for StructLitNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for StructLit<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STRUCT_LIT => Some(StructLit { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> StructLitNode<R> {
    pub fn borrowed(&self) -> StructLit {
        StructLitNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> StructLitNode {
        StructLitNode { syntax: self.syntax.owned() }
    }
}


impl<'a> StructLit<'a> {}

// StructPat
#[derive(Debug, Clone, Copy,)]
pub struct StructPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type StructPat<'a> = StructPatNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<StructPatNode<R1>> for StructPatNode<R2> {
    fn eq(&self, other: &StructPatNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for StructPatNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for StructPatNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for StructPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            STRUCT_PAT => Some(StructPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> StructPatNode<R> {
    pub fn borrowed(&self) -> StructPat {
        StructPatNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> StructPatNode {
        StructPatNode { syntax: self.syntax.owned() }
    }
}


impl<'a> StructPat<'a> {}

// TokenTree
#[derive(Debug, Clone, Copy,)]
pub struct TokenTreeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type TokenTree<'a> = TokenTreeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TokenTreeNode<R1>> for TokenTreeNode<R2> {
    fn eq(&self, other: &TokenTreeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for TokenTreeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for TokenTreeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for TokenTree<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TOKEN_TREE => Some(TokenTree { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> TokenTreeNode<R> {
    pub fn borrowed(&self) -> TokenTree {
        TokenTreeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> TokenTreeNode {
        TokenTreeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> TokenTree<'a> {}

// TraitDef
#[derive(Debug, Clone, Copy,)]
pub struct TraitDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type TraitDef<'a> = TraitDefNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TraitDefNode<R1>> for TraitDefNode<R2> {
    fn eq(&self, other: &TraitDefNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for TraitDefNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for TraitDefNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for TraitDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TRAIT_DEF => Some(TraitDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> TraitDefNode<R> {
    pub fn borrowed(&self) -> TraitDef {
        TraitDefNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> TraitDefNode {
        TraitDefNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for TraitDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for TraitDef<'a> {}
impl<'a> ast::DocCommentsOwner<'a> for TraitDef<'a> {}
impl<'a> TraitDef<'a> {}

// TryExpr
#[derive(Debug, Clone, Copy,)]
pub struct TryExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type TryExpr<'a> = TryExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TryExprNode<R1>> for TryExprNode<R2> {
    fn eq(&self, other: &TryExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for TryExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for TryExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for TryExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TRY_EXPR => Some(TryExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> TryExprNode<R> {
    pub fn borrowed(&self) -> TryExpr {
        TryExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> TryExprNode {
        TryExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> TryExpr<'a> {}

// TupleExpr
#[derive(Debug, Clone, Copy,)]
pub struct TupleExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type TupleExpr<'a> = TupleExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TupleExprNode<R1>> for TupleExprNode<R2> {
    fn eq(&self, other: &TupleExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for TupleExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for TupleExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for TupleExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TUPLE_EXPR => Some(TupleExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> TupleExprNode<R> {
    pub fn borrowed(&self) -> TupleExpr {
        TupleExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> TupleExprNode {
        TupleExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> TupleExpr<'a> {}

// TuplePat
#[derive(Debug, Clone, Copy,)]
pub struct TuplePatNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type TuplePat<'a> = TuplePatNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TuplePatNode<R1>> for TuplePatNode<R2> {
    fn eq(&self, other: &TuplePatNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for TuplePatNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for TuplePatNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for TuplePat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TUPLE_PAT => Some(TuplePat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> TuplePatNode<R> {
    pub fn borrowed(&self) -> TuplePat {
        TuplePatNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> TuplePatNode {
        TuplePatNode { syntax: self.syntax.owned() }
    }
}


impl<'a> TuplePat<'a> {}

// TupleStructPat
#[derive(Debug, Clone, Copy,)]
pub struct TupleStructPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type TupleStructPat<'a> = TupleStructPatNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TupleStructPatNode<R1>> for TupleStructPatNode<R2> {
    fn eq(&self, other: &TupleStructPatNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for TupleStructPatNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for TupleStructPatNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for TupleStructPat<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TUPLE_STRUCT_PAT => Some(TupleStructPat { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> TupleStructPatNode<R> {
    pub fn borrowed(&self) -> TupleStructPat {
        TupleStructPatNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> TupleStructPatNode {
        TupleStructPatNode { syntax: self.syntax.owned() }
    }
}


impl<'a> TupleStructPat<'a> {}

// TupleType
#[derive(Debug, Clone, Copy,)]
pub struct TupleTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type TupleType<'a> = TupleTypeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TupleTypeNode<R1>> for TupleTypeNode<R2> {
    fn eq(&self, other: &TupleTypeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for TupleTypeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for TupleTypeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for TupleType<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TUPLE_TYPE => Some(TupleType { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> TupleTypeNode<R> {
    pub fn borrowed(&self) -> TupleType {
        TupleTypeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> TupleTypeNode {
        TupleTypeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> TupleType<'a> {}

// TypeDef
#[derive(Debug, Clone, Copy,)]
pub struct TypeDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type TypeDef<'a> = TypeDefNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TypeDefNode<R1>> for TypeDefNode<R2> {
    fn eq(&self, other: &TypeDefNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for TypeDefNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for TypeDefNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for TypeDef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TYPE_DEF => Some(TypeDef { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> TypeDefNode<R> {
    pub fn borrowed(&self) -> TypeDef {
        TypeDefNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> TypeDefNode {
        TypeDefNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for TypeDef<'a> {}
impl<'a> ast::TypeParamsOwner<'a> for TypeDef<'a> {}
impl<'a> ast::AttrsOwner<'a> for TypeDef<'a> {}
impl<'a> ast::DocCommentsOwner<'a> for TypeDef<'a> {}
impl<'a> TypeDef<'a> {}

// TypeParam
#[derive(Debug, Clone, Copy,)]
pub struct TypeParamNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type TypeParam<'a> = TypeParamNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TypeParamNode<R1>> for TypeParamNode<R2> {
    fn eq(&self, other: &TypeParamNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for TypeParamNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for TypeParamNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for TypeParam<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TYPE_PARAM => Some(TypeParam { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> TypeParamNode<R> {
    pub fn borrowed(&self) -> TypeParam {
        TypeParamNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> TypeParamNode {
        TypeParamNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::NameOwner<'a> for TypeParam<'a> {}
impl<'a> TypeParam<'a> {}

// TypeParamList
#[derive(Debug, Clone, Copy,)]
pub struct TypeParamListNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type TypeParamList<'a> = TypeParamListNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TypeParamListNode<R1>> for TypeParamListNode<R2> {
    fn eq(&self, other: &TypeParamListNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for TypeParamListNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for TypeParamListNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for TypeParamList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            TYPE_PARAM_LIST => Some(TypeParamList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> TypeParamListNode<R> {
    pub fn borrowed(&self) -> TypeParamList {
        TypeParamListNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> TypeParamListNode {
        TypeParamListNode { syntax: self.syntax.owned() }
    }
}


impl<'a> TypeParamList<'a> {
    pub fn type_params(self) -> impl Iterator<Item = TypeParam<'a>> + 'a {
        super::children(self)
    }

    pub fn lifetime_params(self) -> impl Iterator<Item = LifetimeParam<'a>> + 'a {
        super::children(self)
    }
}

// TypeRef
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TypeRef<'a> {
    ParenType(ParenType<'a>),
    TupleType(TupleType<'a>),
    NeverType(NeverType<'a>),
    PathType(PathType<'a>),
    PointerType(PointerType<'a>),
    ArrayType(ArrayType<'a>),
    SliceType(SliceType<'a>),
    ReferenceType(ReferenceType<'a>),
    PlaceholderType(PlaceholderType<'a>),
    FnPointerType(FnPointerType<'a>),
    ForType(ForType<'a>),
    ImplTraitType(ImplTraitType<'a>),
    DynTraitType(DynTraitType<'a>),
}

impl<'a> AstNode<'a> for TypeRef<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            PAREN_TYPE => Some(TypeRef::ParenType(ParenType { syntax })),
            TUPLE_TYPE => Some(TypeRef::TupleType(TupleType { syntax })),
            NEVER_TYPE => Some(TypeRef::NeverType(NeverType { syntax })),
            PATH_TYPE => Some(TypeRef::PathType(PathType { syntax })),
            POINTER_TYPE => Some(TypeRef::PointerType(PointerType { syntax })),
            ARRAY_TYPE => Some(TypeRef::ArrayType(ArrayType { syntax })),
            SLICE_TYPE => Some(TypeRef::SliceType(SliceType { syntax })),
            REFERENCE_TYPE => Some(TypeRef::ReferenceType(ReferenceType { syntax })),
            PLACEHOLDER_TYPE => Some(TypeRef::PlaceholderType(PlaceholderType { syntax })),
            FN_POINTER_TYPE => Some(TypeRef::FnPointerType(FnPointerType { syntax })),
            FOR_TYPE => Some(TypeRef::ForType(ForType { syntax })),
            IMPL_TRAIT_TYPE => Some(TypeRef::ImplTraitType(ImplTraitType { syntax })),
            DYN_TRAIT_TYPE => Some(TypeRef::DynTraitType(DynTraitType { syntax })),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> {
        match self {
            TypeRef::ParenType(inner) => inner.syntax(),
            TypeRef::TupleType(inner) => inner.syntax(),
            TypeRef::NeverType(inner) => inner.syntax(),
            TypeRef::PathType(inner) => inner.syntax(),
            TypeRef::PointerType(inner) => inner.syntax(),
            TypeRef::ArrayType(inner) => inner.syntax(),
            TypeRef::SliceType(inner) => inner.syntax(),
            TypeRef::ReferenceType(inner) => inner.syntax(),
            TypeRef::PlaceholderType(inner) => inner.syntax(),
            TypeRef::FnPointerType(inner) => inner.syntax(),
            TypeRef::ForType(inner) => inner.syntax(),
            TypeRef::ImplTraitType(inner) => inner.syntax(),
            TypeRef::DynTraitType(inner) => inner.syntax(),
        }
    }
}

impl<'a> TypeRef<'a> {}

// UseItem
#[derive(Debug, Clone, Copy,)]
pub struct UseItemNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type UseItem<'a> = UseItemNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<UseItemNode<R1>> for UseItemNode<R2> {
    fn eq(&self, other: &UseItemNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for UseItemNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for UseItemNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for UseItem<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            USE_ITEM => Some(UseItem { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> UseItemNode<R> {
    pub fn borrowed(&self) -> UseItem {
        UseItemNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> UseItemNode {
        UseItemNode { syntax: self.syntax.owned() }
    }
}


impl<'a> UseItem<'a> {
    pub fn use_tree(self) -> Option<UseTree<'a>> {
        super::child_opt(self)
    }
}

// UseTree
#[derive(Debug, Clone, Copy,)]
pub struct UseTreeNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type UseTree<'a> = UseTreeNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<UseTreeNode<R1>> for UseTreeNode<R2> {
    fn eq(&self, other: &UseTreeNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for UseTreeNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for UseTreeNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for UseTree<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            USE_TREE => Some(UseTree { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> UseTreeNode<R> {
    pub fn borrowed(&self) -> UseTree {
        UseTreeNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> UseTreeNode {
        UseTreeNode { syntax: self.syntax.owned() }
    }
}


impl<'a> UseTree<'a> {
    pub fn path(self) -> Option<Path<'a>> {
        super::child_opt(self)
    }

    pub fn use_tree_list(self) -> Option<UseTreeList<'a>> {
        super::child_opt(self)
    }
}

// UseTreeList
#[derive(Debug, Clone, Copy,)]
pub struct UseTreeListNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type UseTreeList<'a> = UseTreeListNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<UseTreeListNode<R1>> for UseTreeListNode<R2> {
    fn eq(&self, other: &UseTreeListNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for UseTreeListNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for UseTreeListNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for UseTreeList<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            USE_TREE_LIST => Some(UseTreeList { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> UseTreeListNode<R> {
    pub fn borrowed(&self) -> UseTreeList {
        UseTreeListNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> UseTreeListNode {
        UseTreeListNode { syntax: self.syntax.owned() }
    }
}


impl<'a> UseTreeList<'a> {
    pub fn use_trees(self) -> impl Iterator<Item = UseTree<'a>> + 'a {
        super::children(self)
    }
}

// WhereClause
#[derive(Debug, Clone, Copy,)]
pub struct WhereClauseNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type WhereClause<'a> = WhereClauseNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<WhereClauseNode<R1>> for WhereClauseNode<R2> {
    fn eq(&self, other: &WhereClauseNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for WhereClauseNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for WhereClauseNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for WhereClause<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            WHERE_CLAUSE => Some(WhereClause { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> WhereClauseNode<R> {
    pub fn borrowed(&self) -> WhereClause {
        WhereClauseNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> WhereClauseNode {
        WhereClauseNode { syntax: self.syntax.owned() }
    }
}


impl<'a> WhereClause<'a> {}

// WhileExpr
#[derive(Debug, Clone, Copy,)]
pub struct WhileExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type WhileExpr<'a> = WhileExprNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<WhileExprNode<R1>> for WhileExprNode<R2> {
    fn eq(&self, other: &WhileExprNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for WhileExprNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for WhileExprNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for WhileExpr<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            WHILE_EXPR => Some(WhileExpr { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> WhileExprNode<R> {
    pub fn borrowed(&self) -> WhileExpr {
        WhileExprNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> WhileExprNode {
        WhileExprNode { syntax: self.syntax.owned() }
    }
}


impl<'a> ast::LoopBodyOwner<'a> for WhileExpr<'a> {}
impl<'a> WhileExpr<'a> {
    pub fn condition(self) -> Option<Condition<'a>> {
        super::child_opt(self)
    }
}

// Whitespace
#[derive(Debug, Clone, Copy,)]
pub struct WhitespaceNode<R: TreeRoot<RaTypes> = OwnedRoot> {
    pub(crate) syntax: SyntaxNode<R>,
}
pub type Whitespace<'a> = WhitespaceNode<RefRoot<'a>>;

impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<WhitespaceNode<R1>> for WhitespaceNode<R2> {
    fn eq(&self, other: &WhitespaceNode<R1>) -> bool { self.syntax == other.syntax }
}
impl<R: TreeRoot<RaTypes>> Eq for WhitespaceNode<R> {}
impl<R: TreeRoot<RaTypes>> Hash for WhitespaceNode<R> {
    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }
}

impl<'a> AstNode<'a> for Whitespace<'a> {
    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {
        match syntax.kind() {
            WHITESPACE => Some(Whitespace { syntax }),
            _ => None,
        }
    }
    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }
}

impl<R: TreeRoot<RaTypes>> WhitespaceNode<R> {
    pub fn borrowed(&self) -> Whitespace {
        WhitespaceNode { syntax: self.syntax.borrowed() }
    }
    pub fn owned(&self) -> WhitespaceNode {
        WhitespaceNode { syntax: self.syntax.owned() }
    }
}


impl<'a> Whitespace<'a> {}

